export EDITOR="emacsclient --alternate-editor=emacs --socket-name /tmp/emacs/anrs/server"
export CLICOLOR=1
export LSCOLORS=Fxbxaxdxcxegedabagacad
export PS1="\[\e[1;31m\]\u@\h\[\e[m\] \[\e[1;36m\]\t \[\e[1;32m\]\`pwd\`\n\[\e[1;33m\]\$(show-git-branch)\[\e[1;35m\]$ \[\e[m\]"
export PATH="$HOME/.krew/bin:$HOME/.local/bin:$HOME/go/bin:$PATH"
export TERM=xterm-256color
export GOPRIVATE="gitlab.agodadev.io/*"
export GONOPROXY="gitlab.agodadev.io/*"
export GONOSUMDB="gitlab.agodadev.io/*"

alias gp="git push"
alias gpo="gp origin"
alias gc="git ci"
alias gfo="git fetch origin --prune"
alias gs="git st"
alias ll="ls -alht"
alias rc="find . -iname '*.py' -or -iname '*.rs' -or -iname '*.go' -or -iname '*.java' -not -path './vendor/*' > cscope.files && cscope -bR"
alias emacs="emacs -nw"
alias esc=$EDITOR
alias k=kubectl

if [[ "$(uname)" == "Darwin" ]]; then
	# To silence a warning of the default interactive shell is now zsh.
    export BASH_SILENCE_DEPRECATION_WARNING=1

    export HOMEBREW_PREFIX="/opt/homebrew"
    export HOMEBREW_CELLAR="/opt/homebrew/Cellar"
    export HOMEBREW_REPOSITORY="/opt/homebrew"
    export PATH="/opt/homebrew/bin:/opt/homebrew/sbin${PATH+:$PATH}"
    export MANPATH="/opt/homebrew/share/man${MANPATH+:$MANPATH}:"
    export INFOPATH="/opt/homebrew/share/info:${INFOPATH:-}"

    # The ggrep is compatible to the Linux grep. 
    alias grep=ggrep

    brew_etc="$(brew --prefix)/etc" && [[ -r "${brew_etc}/profile.d/bash_completion.sh" ]] && . "${brew_etc}/profile.d/bash_completion.sh"
elif [[ "$(uname)" == "Linux" ]]; then
    source /usr/share/bash-completion/bash_completion

    # Added by OrbStack: command-line tools and integration
    # Comment this line if you don't want it to be added again.
    source ~/.orbstack/shell/init.bash 2>/dev/null || :
fi

source <(k completion bash)
complete -o default -F __start_kubectl k

init-cilium() {
    if [ -z "$3" ]; then
        echo "Error: The 3rd parameter (zone) is required and cannot be empty." >&2
        return 1
    fi
    helm --kube-context $1.$2 upgrade --install \
      -n kube-system \
      --set k8sServiceHost=$2.$1.k8s.$3.agoda.is \
      --set k8sServicePort=443 \
      --set ipam.mode=kubernetes \
      cilium cilium/cilium
}

go-cover() {
    go test -coverprofile=cover.out $1 ${@:2} && go tool cover -html=cover.out -o cover.html
}

kubectl-curl() {
    kubectl --context $1 run $2 --image=radial/busyboxplus:curl -i --tty --rm
}

krew-install() {
    pushd .
    cd "$(mktemp -d)" &&
    OS="$(uname | tr '[:upper:]' '[:lower:]')" &&
    ARCH="$(uname -m | sed -e 's/x86_64/amd64/' -e 's/\(arm\)\(64\)\?.*/\1\2/' -e 's/aarch64$/arm64/')" &&
    KREW="krew-${OS}_${ARCH}" &&
    curl -fsSLO "https://github.com/kubernetes-sigs/krew/releases/latest/download/${KREW}.tar.gz" &&
    tar zxvf "${KREW}.tar.gz" &&
    ./"${KREW}" install krew
    popd
}

# The function "gpoc" must be defined as a function, rather than an alias,
# that's because the alias caches its result.
# This means that when "gpoc" is initially called on branch-a,
# possible subsequent calls to "gpoc" will all refer to branch-a.
gpoc() {
    gpo $(git-branch):$(git-branch)
}

show-git-branch() {
    local br=$(git-branch)
    echo -n $br
    [[ -n $br ]] && echo ' '
}

git-branch() {
    git rev-parse --abbrev-ref HEAD 2>/dev/null
}

startvm() {
  local vmdir="${HOME}/Virtual Machines.localized/Ubuntu 64-bit Arm Server 24.04.1.vmwarevm"
  local vmx_path="${vmdir}/Ubuntu 64-bit Arm Server 24.04.1.vmx"

  # Check if the 'vmrun' command exists.
  if ! command -v vmrun &> /dev/null; then
    echo "Error: 'vmrun' command not found. Please ensure VMware Fusion is installed and in the PATH." >&2
    return 1
  fi

  # Check if the VMX file itself exists to prevent path errors.
  if [ ! -f "${vmx_path}" ]; then
    echo "Error: VMX file not found at '${vmx_path}'" >&2
    return 1
  fi

  echo "Checking status of VM: ${vmx_path}"

  # Correctly check if the VM is running.
  # The 'if' statement evaluates the exit code of the last command in the pipeline (grep).
  # -q: quiet mode, suppresses stdout and returns an exit code immediately on first match.
  # -F: treat pattern as a fixed string, not a regular expression.
  # -x: match the entire line.
  if vmrun list | grep -qFx "${vmx_path}"; then
    echo "VM is already running. Nothing to do."
    return 0
  fi

  echo "VM is not running. Cleaning up potential lock files..."
  find "${vmdir}" -name "*.lck" -maxdepth 1 -exec rm -rf {} +
  
  echo "Attempting to start VM in headless mode..."

  if vmrun start "${vmx_path}" nogui; then
    echo "VM started successfully."
    return 0
  else
    echo "Error: Failed to start VM. Check vmrun output above for details." >&2
    return 1
  fi
}

eval "$(zoxide init bash)"

j() {
  local dir=$(
    zoxide query --list --score |
    fzf --height 40% --layout reverse --info inline \
        --nth 2.. --tac --no-sort --query "$*" \
        --bind 'enter:become:echo {2..}'
  ) && cd "$dir"
}

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

if [ -f ~/.authinfo ]; then
    GEMINI_API_KEY_VALUE=$(grep 'generativelanguage.googleapis.com' ~/.authinfo | awk '{print $NF}')
    if [ -n "$GEMINI_API_KEY_VALUE" ]; then
        export GEMINI_API_KEY=$GEMINI_API_KEY_VALUE
    fi
fi
