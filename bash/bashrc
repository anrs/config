export EDITOR="emacsclient --alternate-editor=emacs --socket-name /tmp/emacs/$(id -u)/server"
export CLICOLOR=1
export LSCOLORS=Fxbxaxdxcxegedabagacad
export PS1="\[\e[1;31m\]\u@\h\[\e[m\] \[\e[1;36m\]\t \[\e[1;32m\]\`pwd\`\n\[\e[1;33m\]\$(show-git-branch)\[\e[1;35m\]$ \[\e[m\]"
export PATH="$HOME/.krew/bin:$HOME/.local/bin:$HOME/go/bin:$PATH"
export TERM=xterm-256color
export GOPRIVATE="gitlab.agodadev.io/*,github.com/*"
export GONOPROXY="gitlab.agodadev.io/*,github.com/*"
export GONOSUMDB="gitlab.agodadev.io/*,github.com/*"

alias gp="git push"
alias gpo="gp origin"
alias gc="git ci"
alias gfo="git fetch origin --prune"
alias gs="git st"
alias ll="ls -alht"
alias rc="find . -iname '*.py' -or -iname '*.rs' -or -iname '*.go' -or -iname '*.java' -not -path './vendor/*' > cscope.files && cscope -bR"
alias emacs="emacs -nw"
alias esc=$EDITOR
alias k=kubectl

if [[ "$(uname)" == "Darwin" ]]; then
	# To silence a warning of the default interactive shell is now zsh.
    export BASH_SILENCE_DEPRECATION_WARNING=1

    export HOMEBREW_PREFIX="/opt/homebrew"
    export HOMEBREW_CELLAR="/opt/homebrew/Cellar"
    export HOMEBREW_REPOSITORY="/opt/homebrew"
    export PATH="/opt/homebrew/bin:/opt/homebrew/sbin${PATH+:$PATH}"
    export MANPATH="/opt/homebrew/share/man${MANPATH+:$MANPATH}:"
    export INFOPATH="/opt/homebrew/share/info:${INFOPATH:-}"

    # The ggrep is compatible to the Linux grep. 
    # To install ggrep, run: brew install grep
    alias grep=ggrep

    brew_etc="$(brew --prefix)/etc" && [[ -r "${brew_etc}/profile.d/bash_completion.sh" ]] && . "${brew_etc}/profile.d/bash_completion.sh"
elif [[ "$(uname)" == "Linux" ]]; then
    source /usr/share/bash-completion/bash_completion

    # Added by OrbStack: command-line tools and integration
    # Comment this line if you don't want it to be added again.
    source ~/.orbstack/shell/init.bash 2>/dev/null || :
fi

source <(k completion bash)
complete -o default -F __start_kubectl k

init-cilium() {
    if [ -z "$3" ]; then
        echo "Error: The 3rd parameter (zone) is required and cannot be empty." >&2
        return 1
    fi
    helm --kube-context $1.$2 upgrade --install \
      -n kube-system \
      --set k8sServiceHost=$2.$1.k8s.$3.agoda.is \
      --set k8sServicePort=443 \
      --set ipam.mode=kubernetes \
      cilium cilium/cilium
}

go-cover() {
    go test -coverprofile=cover.out $1 ${@:2} && go tool cover -html=cover.out -o cover.html
}

kubectl-curl() {
    kubectl --context $1 run $2 --image=radial/busyboxplus:curl -i --tty --rm
}

krew-install() {
    pushd .
    cd "$(mktemp -d)" &&
    OS="$(uname | tr '[:upper:]' '[:lower:]')" &&
    ARCH="$(uname -m | sed -e 's/x86_64/amd64/' -e 's/\(arm\)\(64\)\?.*/\1\2/' -e 's/aarch64$/arm64/')" &&
    KREW="krew-${OS}_${ARCH}" &&
    curl -fsSLO "https://github.com/kubernetes-sigs/krew/releases/latest/download/${KREW}.tar.gz" &&
    tar zxvf "${KREW}.tar.gz" &&
    ./"${KREW}" install krew
    popd
}

# The function "gpoc" must be defined as a function, rather than an alias,
# that's because the alias caches its result.
# This means that when "gpoc" is initially called on branch-a,
# possible subsequent calls to "gpoc" will all refer to branch-a.
gpoc() {
    gpo $(git-branch):$(git-branch)
}

show-git-branch() {
    local br=$(git-branch)
    echo -n $br
    [[ -n $br ]] && echo ' '
}

git-branch() {
    git rev-parse --abbrev-ref HEAD 2>/dev/null
}

startvm() {
  # Check if the 'vmrun' command exists.
  if ! command -v vmrun &> /dev/null; then
    echo "Error: 'vmrun' command not found. Please ensure VMware Fusion is installed and in the PATH." >&2
    return 1
  fi

  local vm_dir_base="${HOME}/Virtual Machines.localized"
  
  # shopt -s nullglob makes glob patterns expand to nothing if no matches are found.
  shopt -s nullglob
  local vm_paths=("${vm_dir_base}"/*.vmwarevm)
  shopt -u nullglob # Turn it off again to not affect the rest of the shell

  local vm_count=${#vm_paths[@]}
  local vmdir

  if [ $vm_count -eq 0 ]; then
    echo "No VMs found in ${vm_dir_base}" >&2
    return 1
  elif [ $vm_count -eq 1 ]; then
    vmdir="${vm_paths[0]}"
    echo "Found one VM, proceeding with: $(basename "${vmdir}")"
  else
    echo "Please select a VM to start:"
    local vm_names=()
    for vm_path in "${vm_paths[@]}"; do
      vm_names+=("$(basename "${vm_path}")")
    done

    # PS3 is the prompt for the select command
    PS3="Enter number: "
    select vm_name in "${vm_names[@]}"; do
      if [ -n "$vm_name" ]; then
        vmdir="${vm_dir_base}/${vm_name}"
        break
      else
        echo "Invalid selection. Please try again."
      fi
    done
  fi

  if [ -z "$vmdir" ]; then
    echo "No VM selected. Aborting." >&2
    return 1
  fi

  # Find the .vmx file within the selected directory. Should only be one.
  shopt -s nullglob
  local vmx_files=("${vmdir}"/*.vmx)
  shopt -u nullglob
  if [ ${#vmx_files[@]} -eq 0 ]; then
      echo "Error: No .vmx file found in '${vmdir}'" >&2
      return 1
  fi
  # In case there are multiple, just take the first one.
  local vmx_path="${vmx_files[0]}"

  # Check if the VMX file itself exists to prevent path errors.
  if [ ! -f "${vmx_path}" ]; then
    echo "Error: VMX file not found at '${vmx_path}'" >&2
    return 1
  fi

  echo "Checking status of VM: $(basename "${vmdir}")"

  if vmrun list | grep -qFx "${vmx_path}"; then
    echo "VM is already running. Nothing to do."
    return 0
  fi

  echo "VM is not running. Cleaning up potential lock files..."
  find "${vmdir}" -name "*.lck" -maxdepth 1 -exec rm -rf {} +
  
  echo "Attempting to start VM in headless mode..."

  if vmrun start "${vmx_path}" nogui; then
    echo "VM started successfully."
    return 0
  else
    echo "Error: Failed to start VM. Check vmrun output above for details." >&2
    return 1
  fi
}

eval "$(zoxide init bash)"

j() {
  local dir=$(
    zoxide query --list --score |
    fzf --height 40% --layout reverse --info inline \
        --nth 2.. --tac --no-sort --query "$*" \
        --bind 'enter:become:echo {2..}'
  ) && cd "$dir"
}

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

if [ -f ~/.authinfo ]; then
    GEMINI_API_KEY_VALUE=$(grep 'generativelanguage.googleapis.com' ~/.authinfo | awk '{print $NF}')
    if [ -n "$GEMINI_API_KEY_VALUE" ]; then
        export GEMINI_API_KEY=$GEMINI_API_KEY_VALUE
    fi
fi
